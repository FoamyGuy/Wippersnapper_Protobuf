// SPDX-FileCopyrightText: 2021 Brent Rubell for Adafruit Industries
// SPDX-License-Identifier: MIT
syntax = "proto3";

package wippersnapper.i2c.v1;

/**
* I2CScanRequest represents an `Adafruit_I2CDevice::begin` call
* which attempts to detect the address with an I2C scan.
*/
message I2CScanRequest {
  uint32 address = 1; /** The 7-bit I2C address for the device. */
}

/**
* I2CScanResponse represents the response of a call to
* `Adafruit_I2CDevice::begin`.
*/
message I2CScanResponse {
  bool is_address_found = 1; /** True if an I2C address was found on the bus, False otherwise.. */
}

/**
* AHTInitRequest represents the request to initialize
* an AHTX0 temperature/humidity sensor.
*/
message AHTInitRequest {
  bool enable_temperature = 1; /** True if AHTX0 expects to init. the temperature data object, False otherwise. */
  bool enable_humidity    = 2; /** True if AHTX0 expects to init. the humidity data object, False otherwise. */
}

/**
* AHTInitResponse represents the response from the AHTX0 temperature/data
* sensor's initialization.
*/
message AHTInitResponse {
  bool is_init_success           = 1; /** True if AHTX0 initialization was successful. */
  repeated SensorDetails details = 2; /** Provides basic information about each sensor initialized. */
}

/** Adafruit Unified Sensor Library Messages. */

/**
* SensorDetails is used to describe basic information about a specific sensor.
*/
message SensorDetails {
  string name      = 1; /** The sensor name or ID, up to a maximum of twelve characters (ex. "MPL115A2"). */
  int32 version    = 2; /** The version of the sensor HW and the driver to allow us to differentiate versions of the board or driver. */
  int32 id         = 3; /** A unique sensor identifier that is used to differentiate this specific sensor instance from any others that are present on the system or in the sensor network */
  SensorType type  = 4; /** The sensor type, based on SensorType */
  float max_value  = 5; /** The maximum value that this sensor can return (in the appropriate SI unit) */
  float min_value  = 6; /** The minimum value that this sensor can return (in the appropriate SI unit) */
  float resolution = 7; /** The smallest difference between two values that this sensor can report (in the appropriate SI unit) */
  int32 min_delay  = 8; /** The minimum delay in microseconds between two sensor events, or '0' if there is no constant sensor rate */
}

/**
* SensorEvent  is used to return sensor data from any sensor supported by the abstraction layer,
* using standard SI units and scales.
*/
message SensorEvent {
  int32 version   = 1; /** Contain 'sizeof(sensors_event_t)' to identify which version of the API we're using in case this changes in the future */
  int32 sensor_id = 2; /** A unique sensor identifier that is used to differentiate this specific sensor instance from any others that are present on the system or in the sensor network */
  SensorType type = 3; /** The sensor type, based on SensorType */
  int32 timestamp = 4; /** Time in milliseconds when the sensor value was read */
  oneof event_data {
    float temperature       = 5;
    float distance          = 6;
    float light             = 7;
    float pressure          = 8;
    float relative_humidity = 9;
    float current           = 10;
    float voltage           = 11;
  }
}

/**
* SensorType allows us determine what types of units the sensor uses, etc.
*/
enum SensorType {
  SENSOR_TYPE_UNSPECIFIED         = 0;
  SENSOR_TYPE_ACCELEROMETER       = 1;
  SENSOR_TYPE_MAGNETIC_FIELD      = 2;
  SENSOR_TYPE_ORIENTATION         = 3;
  SENSOR_TYPE_GYROSCOPE           = 4;
  SENSOR_TYPE_LIGHT               = 5;
  SENSOR_TYPE_PRESSURE            = 6;
  SENSOR_TYPE_PROXIMITY           = 8;
  SENSOR_TYPE_GRAVITY             = 9;
  SENSOR_TYPE_LINEAR_ACCELERATION = 10;
  SENSOR_TYPE_ROTATION_VECTOR     = 11;
  SENSOR_TYPE_RELATIVE_HUMIDITY   = 12;
  SENSOR_TYPE_AMBIENT_TEMPERATURE = 13;
  SENSOR_TYPE_VOLTAGE             = 15;
  SENSOR_TYPE_CURRENT             = 16;
  SENSOR_TYPE_COLOR               = 17;
}